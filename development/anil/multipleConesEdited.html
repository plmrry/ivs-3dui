<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Cones on a Sphere</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			#oldie { background-color: #ddd !important }
		</style>
	</head>
	<body>
		<script src="../../build/three.min.js"></script>
		<script src="../../examples/js/Detector.js"></script>
		<script src="FlyControlsUpdated.js"></script>
		<script src="../../examples/js/controls/TrackballControls.js"></script>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.16/d3.js"></script>

    <script>
      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var audio, listener;
			var soundCones = [];
			var container;
      var camera, controls, trackball, scene, renderer;
      var mouse, raycaster, isShiftDown = false;

      var soundCones = [];
			var soundConeMaterial, soundConeGeo;
      var objects = [];

      var positionEnabled = true;
      var velocityEnabled = true;
      var orientationEnabled = true;

			var clock = new THREE.Clock();

			var MOUSEDOWN = false;

      init();
			animate();

      function init(){
				setupAudio();

				container = document.createElement('div');
				document.body.appendChild(container);

				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 10000);
				camera.position.set(0, 0, 1300);
				//camera.lookAt(new THREE.Vector3());

				controls = new THREE.FlyControls(camera);
				controls.dragToLook = true;
				controls.movementSpeed = 1000;
				controls.domElement = container;
				controls.rollSpeed = Math.PI / 24;
				controls.autoForward = false;
				controls.dragToLook = false;

				trackball = new THREE.TrackballControls(camera);

				trackball.rotateSpeed = 4.0;
				trackball.zoomSpeed = 1.2;
				trackball.panSpeed = 0.8;

				trackball.noZoom = false;
				trackball.noPan = false;

				trackball.staticMoving = true;
				trackball.dynamicDampingFactor = 0.3;

				trackball.keys = [ 65, 83, 68 ];

				//trackball.addEventListener( 'change', render );

				scene = new THREE.Scene();

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				var geometry = new THREE.SphereBufferGeometry(300, 100, 100);

				sphere = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({color: 0xFFFFFF, opacity: 0.6}));
				sphere.material.transparent = true;
				scene.add(sphere);

				objects.push(sphere);

				// Lights
				var ambientLight = new THREE.AmbientLight(0x606060);
				scene.add(ambientLight);

				var directionalLight = new THREE.DirectionalLight(0xffffff);
				directionalLight.position.set(1, 0.75, 0.5).normalize();
				scene.add(directionalLight);

				renderer = new THREE.WebGLRenderer({antialias: true});
				renderer.setClearColor(0xf0f0f0);
				renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				container.appendChild(renderer.domElement);

				document.addEventListener('mousemove', onDocumentMouseMove, false);
				document.addEventListener('mousedown', onDocumentMouseDown, false);
				document.addEventListener('mouseup', onDocumentMouseUp, false);
				document.addEventListener('keydown', onDocumentKeyDown, false);
				document.addEventListener('keyup', onDocumentKeyUp, false);

				window.addEventListener('resize', onWindowResize, false);
			}

			function createCone(orientation){
				soundConeGeo = new THREE.CylinderGeometry(100, 0, 600, 100, 1, true);
				soundConeGeo.translate(0, 300, 0);
				soundConeGeo.rotateX(Math.PI/2.);
				soundConeMaterial = new THREE.MeshBasicMaterial({color: 0x80FFE5, opacity: 0.5});
				soundCones.push(new THREE.Mesh(soundConeGeo, soundConeMaterial));
				soundCones[soundCones.length - 1].material.side = THREE.DoubleSide;
				soundCones[soundCones.length - 1].material.transparent = true;
				soundCones[soundCones.length - 1].lookAt(orientation);

				scene.add(soundCones[soundCones.length - 1]);

				soundCones[soundCones.length - 1] = soundCones[0];
				soundCones[soundCones.length - 1].sound = loadSound('samples/wetShort.wav');
				soundCones[soundCones.length - 1].sound.panner.coneInnerAngle = 0.01*180/Math.PI;
				soundCones[soundCones.length - 1].sound.panner.coneOuterAngle = 1*180/Math.PI;
				soundCones[soundCones.length - 1].sound.panner.coneOuterGain = 0.03;
			}

      function setupAudio(){
				var a = {};
				audio = a;

        window.AudioContext = window.AudioContext || window.webkitAudioContext;

        a.context = new AudioContext();
				a.context.listener.setOrientation(0,0,-1,0,1,0);
				a.context.listener.setPosition(0, 0, 1);
        a.destination = a.context.createGain();
        a.destination.connect(a.context.destination);
      }

      function loadSound(soundFileName){
				var context = audio.context;

        var sound = {};
        sound.source = context.createBufferSource();
        sound.source.loop = true;
        sound.panner = context.createPanner();
        sound.panner.panningModel = 'HRTF';
        sound.volume = context.createGain();

        sound.source.connect(sound.volume);
        sound.volume.connect(sound.panner);
        sound.panner.connect(audio.destination);

        loadBuffer(soundFileName, function(buffer){
          sound.buffer = buffer;
          sound.source.buffer = sound.buffer;
          sound.source.start(context.currentTime + 0.020);
        });

        return sound;
      }

      function loadBuffer(soundFileName, callback){
        var request = new XMLHttpRequest();
        request.open("GET", soundFileName, true);
        request.responseType = "arraybuffer";
        var context = audio.context;
        request.onload = function() {
          context.decodeAudioData(request.response, callback, function() {
            alert("Decoding the audio buffer failed");
          });
        };
        request.send();
        return request;
      }

			function setPosition(object){
				object.sound.panner.position = object.position;
				if (this.orientationEnabled) {
					var vec = new THREE.Vector3(0,0,1);
					var m = object.matrixWorld;
					var mx = m.elements[12], my = m.elements[13], mz = m.elements[14];
					m.elements[12] = m.elements[13] = m.elements[14] = 0;
					vec.applyProjection(m);
					vec.normalize();
					object.sound.panner.setOrientation(vec.x, vec.y, vec.z);
					m.elements[12] = mx;
					m.elements[13] = my;
					m.elements[14] = mz;
				}
			}

			function setPositionAndVelocity(object, audioNode){
				var p = new THREE.Vector3();
				var q = new THREE.Vector3();
				p.setFromMatrixPosition(object.matrixWorld);
				var px = p.x, py = p.y, pz = p.z;

				object.updateMatrixWorld();
				q.setFromMatrixPosition(object.matrixWorld);
				var dx = q.x-px, dy = q.y-py, dz = q.z-pz;
				audioNode.setPosition(q.x/1300., q.y/1300., q.z/1300.);
			}

			function setListenerPosition(object) {
				setPositionAndVelocity(object, audio.context.listener);
				var m = object.matrix;
				var mx = m.elements[12], my = m.elements[13], mz = m.elements[14];
				m.elements[12] = m.elements[13] = m.elements[14] = 0;

				var vec = new THREE.Vector3(0,0,1);
				vec.applyProjection(m);
				vec.normalize();

				var up = new THREE.Vector3(0,-1,0);
				up.applyProjection(m);
				up.normalize();

				audio.context.listener.setOrientation(vec.x, vec.y, vec.z, up.x, up.y, up.z);

				m.elements[12] = mx;
				m.elements[13] = my;
				m.elements[14] = mz;
			}

			function onWindowResize(){
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			}

			function onDocumentMouseMove( event ){
				event.preventDefault();
				mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
				raycaster.setFromCamera(mouse, camera);

				var x_to_phi = d3.scale.linear().domain([-0.35, 0.35]).range([-Math.PI/2, Math.PI/2])
				var y_to_theta = d3.scale.linear().domain([-0.70, 0.70]).range([Math.PI/2, -Math.PI/2])
				var flipped = d3.scale.linear().domain([-0.70, 0.70]).range([-Math.PI/2, Math.PI/2])

				// soundCones[soundCones.length - 1].rotation.y = Math.PI/2; //mouse.x;
				soundCones[soundCones.length - 1].rotation.y = x_to_phi(mouse.x);
				if (x_to_phi(mouse.x) > Math.PI/2) {
					soundCones[soundCones.length - 1].rotation.x = flipped(mouse.y);
				}
				else {
					soundCones[soundCones.length - 1].rotation.x = y_to_theta(mouse.y);
				}
				//soundCones[soundCones.length - 1].rotation.x = y_to_theta(mouse.y);

				console.log(mouse.x)

				var intersects = raycaster.intersectObjects(objects);
				if (intersects.length > 0 && !MOUSEDOWN){
					// var intersect = intersects[0];
					// soundCones[soundCones.length - 1].lookAt(intersect.point);
					// setPosition(soundCones[soundCones.length - 1]);
				}
				else if(MOUSEDOWN){
					trackball.update();
				}
			}

			function onDocumentMouseDown(event){
				event.preventDefault();
				MOUSEDOWN = true;

				mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects(objects);
				if (intersects.length > 0) {
					var intersect = intersects[0];
					createCone(intersect.point);

					if (isShiftDown){
						if (intersect.object != sphere) {
							scene.remove(intersect.object);
							objects.splice(objects.indexOf(intersect.object), 1);
						}
					}
					else{
	            //var placedCone = new THREE.Mesh(soundConeGeo, soundConeMaterial);
							//placedCone.lookAt(intersect.point);
							//scene.add(placedCone);
	            //objects.push(placedCone);
					}
				}
			}

			function onDocumentMouseUp(event){
				MOUSEDOWN = false;
			}

			function onDocumentKeyDown(event) {
				switch(event.keyCode){
					case 16: isShiftDown = true; break;
				}
			}

			function onDocumentKeyUp(event){
				switch (event.keyCode){
					case 16: isShiftDown = false; break;
				}
			}

			function animate() {
				requestAnimationFrame( animate );
				render();
			}

			function render() {
				renderer.render(scene, camera);

				var delta = clock.getDelta();
 				controls.update(delta);
				setListenerPosition(camera);
			}

    </script>
  </body>
</html>
