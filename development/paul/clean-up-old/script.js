// Generated by CoffeeScript 1.10.0
/* global THREE, d3 */

  var CAMERA_RADIUS, CONE_BOTTOM, DEFAULT_CONE_SPREAD, DEFAULT_OBJECT_HEIGHT, DEFAULT_OBJECT_VOLUME, EDIT_MODE_PHI, EDIT_MODE_ZOOM, INITIAL_PHI, INITIAL_THETA, INITIAL_ZOOM, MAX_CONE_SPREAD, MAX_CONE_VOLUME, MAX_PHI, MIN_PHI, PARENT_SPHERE_COLOR, ROOM_SIZE, ZOOM_AMOUNT, _canvasDragEnd, _canvasDragStart, addCameraControls, addCone, addConeParentWithParams, addMain, addObjectAtPoint, addObjectMode, addSceneControls, allIntersects, apply, cameraPolarTweenFunc, cameraSize, canvasDrag, canvasDragEnd, canvasDragMove, canvasDragStart, degToRad, dom, emitter, f, firstDom, firstModel, firstNdcScales, fromD3drag, fromD3dragHandler, getClientSize, getConeParentWithParams, getFirstCamera, getFloor, getInitialScene, getMainObject, getModeButtons, getMouseFrom, getNdcFromMouse, getRoomObject, highlightObject, log, m, materialIcon, model, modelUpdates, ndc, o, polarToVector, r, raycaster, readyAdd, renderer, setCameraSize, size, stream, tweenColor, tweenStream, updateConeControls, updateConeParent, updateNdcDomain, updateObjectControls;

  Rx.config.longStackSupport = true;

  stream = Rx.Observable;

  raycaster = new THREE.Raycaster();

  log = console.log.bind(console);

  CAMERA_RADIUS = 100;

  INITIAL_THETA = 80;

  INITIAL_PHI = 45;

  INITIAL_ZOOM = 40;

  MIN_PHI = 0.01;

  MAX_PHI = Math.PI * 0.5;

  EDIT_MODE_ZOOM = 90;

  EDIT_MODE_PHI = 85;

  ZOOM_AMOUNT = 2;

  DEFAULT_OBJECT_HEIGHT = 0;

  PARENT_SPHERE_COLOR = new THREE.Color(0, 0, 0);

  ROOM_SIZE = {
    width: 20,
    length: 18,
    height: 3
  };

  DEFAULT_OBJECT_VOLUME = 1;

  DEFAULT_CONE_SPREAD = 0.3;

  MAX_CONE_SPREAD = 2;

  MAX_CONE_VOLUME = 2;

  CONE_BOTTOM = 0.01;

  emitter = (function() {
    var _emitter, subject;
    subject = new Rx.Subject();
    _emitter = function(event) {
      return subject.filter(function(o) {
        return o.event === event;
      }).map(function(o) {
        return o.data;
      });
    };
    _emitter.emit = function(event, data) {
      return subject.onNext({
        event: event,
        data: data
      });
    };
    return _emitter;
  })();

  dom = emitter('start').flatMap(function() {
    return stream.just(firstDom());
  }).shareReplay();

  size = stream.fromEvent(window, 'resize').startWith('first resize').combineLatest(dom, function(a, b) {
    return b;
  }).map(function(dom) {
    // return getClientSize(dom.main.node());
    return {
      width: 600,
      height: 600
    }
  });

  ndc = emitter('start').flatMap(function() {
    return size.map(updateNdcDomain).scan(apply, firstNdcScales());
  });

  cameraSize = size.map(function(size) {
    return function(model) {
      model.camera = setCameraSize(size)(model.camera);
      return model;
    };
  });

  renderer = dom.flatMap(function(dom) {
    var first;
    first = new THREE.WebGLRenderer({
      canvas: dom.canvas,
      antialias: true
    });
    first.shadowMap.enabled = true;
    first.shadowMap.type = THREE.PCFSoftShadowMap;
    first.setSize(500, 500);
    return size.scan(function(r, s) {
      // r.setSize(s.width, s.height);
      // r.setSize(500, 500)
      return r;
    }, first);
  });

  modelUpdates = stream.merge(cameraSize, emitter('modelUpdate'));

  model = emitter('start').flatMap(function() {
    return modelUpdates.scan(function(o, fn) {
      emitter.emit('modelState', o);
      return fn(o);
    }, firstModel());
  });

  (function() {
    var onError, onNext;
    onNext = function(arr) {
      model = arr[0], renderer = arr[1];
      return renderer.render(model.scene, model.camera);
    };
    onError = function(err) {
      return console.error(err.stack);
    };
    return model.combineLatest(renderer).subscribe(onNext, onError);
  })();

  r = emitter('roomIntersects');

  f = emitter('floorIntersects');

  allIntersects = stream.combineLatest(r, f, (function(r, f) {
    return {
      room: r,
      floor: f
    };
  }));

  addObjectMode = dom.flatMap(function(dom) {
    var addObject;
    addObject = dom.modeButtons.select('#object').node();
    return stream.fromEvent(addObject, 'click');
  });

  readyAdd = addObjectMode.map(function() {
    return true;
  }).merge(emitter('cancelAdd').map(function() {
    return false;
  })).startWith(false)["do"](function(d) {
    return log("readyAdd " + d);
  });

  addObjectAtPoint = function(p, volume) {
    var _lineBottom, geometry, line, lineGeom, mat, material, object, s, sphere, update, y;
    console.info("Add object at", p);
    geometry = new THREE.SphereGeometry(0.1, 30, 30);
    material = new THREE.MeshPhongMaterial({
      color: PARENT_SPHERE_COLOR,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    sphere = new THREE.Mesh(geometry, material);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    sphere.name = 'parentSphere';
    sphere._volume = volume || 1;
    sphere.renderOrder = 10;
    lineGeom = new THREE.Geometry();
    _lineBottom = -p.y + (-ROOM_SIZE.height / 2);
    lineGeom.vertices.push(new THREE.Vector3(0, _lineBottom, 0));
    lineGeom.vertices.push(new THREE.Vector3(0, 100, 0));
    lineGeom.computeLineDistances();
    s = 0.3;
    mat = new THREE.LineDashedMaterial({
      color: 0,
      linewidth: 1,
      dashSize: s,
      gapSize: s,
      transparent: true,
      opacity: 0.2
    });
    line = new THREE.Line(lineGeom, mat);
    sphere.add(line);
    object = sphere;
    DEFAULT_OBJECT_HEIGHT = 1;
    y = DEFAULT_OBJECT_HEIGHT;
    object.position.copy(p);
    update = function(model) {
      var i;
      i = model.room.children.length;
      object.name = "object" + i;
      object._id = i;
      model.room.add(object);
      return model;
    };
    emitter.emit('modelUpdate', update);
    emitter.emit('tweenInSphere', sphere);
    emitter.emit('objectAdded', object);
    return object;
  };

  emitter('objectAdded').subscribe(function(o) {});

  highlightObject = function(o) {
    var color;
    color = new THREE.Color("#99ebff");
    color = new THREE.Color("#66c2ff");
    return tweenColor(color)(o).subscribe(function(up) {
      return emitter.emit('modelUpdate', function(m) {
        return m;
      });
    });
  };

  addCone = emitter('domAdded').map(function(dom) {
    return dom.sceneControls.select('#add-cone').node();
  }).filter(function(node) {
    return node != null;
  }).flatMap(function(node) {
    return stream.fromEvent(node, 'click');
  })["do"](function() {
    return console.info('Add cone.');
  }).subscribe(function(event) {
    var obj;
    obj = d3.select(event.target).datum();
    console.log(obj);
    return emitter.emit('addCone', obj);
  });

  emitter('coneAdded').subscribe(function(coneParent) {
    return emitter.emit('selectCone', coneParent);
  });

  emitter('selectCone').withLatestFrom(dom).subscribe(function(arr) {
    var object;
    object = arr[0], dom = arr[1];
    return updateConeControls(dom)([object]);
  });

  getConeParentWithParams = function(params) {
    var CONE_RADIAL_SEGMENTS, cone, coneParent, geometry, material;
    coneParent = new THREE.Object3D();
    Object.assign(coneParent, params);
    coneParent.castShadow = true;
    coneParent.receiveShadow = true;
    CONE_RADIAL_SEGMENTS = 50;
    geometry = new THREE.CylinderGeometry();
    geometry.parameters = {
      radiusBottom: CONE_BOTTOM,
      openEnded: true,
      radialSegments: CONE_RADIAL_SEGMENTS
    };
    geometry = geometry.clone();
    material = new THREE.MeshPhongMaterial({
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    cone = new THREE.Mesh(geometry, material);
    cone.name = 'cone';
    cone.castShadow = true;
    cone.renderOrder = 1;
    cone.receiveShadow = true;
    coneParent.add(cone);
    return coneParent;
  };

  addConeParentWithParams = function(params) {
    return function(obj) {
      var coneParent, i;
      coneParent = getConeParentWithParams(params);
      updateConeParent(coneParent);
      i = obj.children.length;
      coneParent.name = "cone" + i;
      return obj.add(coneParent);
    };
  };

  emitter('addCone').subscribe(function(obj) {
    var params;
    params = {
      _theta: Math.random() * (Math.PI * 2),
      _phi: Math.random() * (Math.PI * 2),
      _volume: DEFAULT_OBJECT_VOLUME,
      _spread: DEFAULT_CONE_SPREAD
    };
    addConeParentWithParams(params)(obj);
    return emitter.emit('modelUpdate', function(m) {
      return m;
    });
  });

  updateConeParent = function(coneParent) {
    var cone, geom, newGeom, params;
    coneParent.rotation.x = coneParent._phi;
    coneParent.rotation.z = coneParent._theta;
    cone = coneParent.getObjectByName('cone');
    geom = cone.geometry;
    params = geom.parameters;
    params.height = coneParent._volume;
    params.radiusTop = coneParent._spread;
    newGeom = geom.clone();
    cone.geometry.dispose();
    cone.geometry = newGeom;
    return cone.position.y = cone.geometry.parameters.height / 2;
  };

  emitter('coneParentUpdate').subscribe(function(coneParent) {
    updateConeParent(coneParent);
    return emitter.emit('modelUpdate', function(m) {
      return m;
    });
  });

  window.emitter = emitter;

  updateConeControls = function(dom) {
    return function(data) {
      var coneControls;
      coneControls = dom.sceneControls.select("#objectControls").select(".card").selectAll("#coneControls").data(data);
      coneControls.enter().append('div').attr({
        id: "coneControls"
      }).call(function(card) {
        return card.append('div').classed('card-block', true).append('h4').classed('card-title', true).text('Cone').append('button').classed('btn btn-secondary pull-right', true).text('add file');
      });
      return coneControls.exit().remove();
    };
  };

  updateObjectControls = function(dom) {
    return function(data) {
      var objectControls;
      objectControls = dom.sceneControls.selectAll("#objectControls").data(data);
      objectControls.enter().append('div').classed('row', true).attr({
        id: 'objectControls'
      }).append('div').classed('col-xs-12', true).append('div').classed('card', true).call(function(card) {
        return card.append('div').classed('card-block', true).append('h4').classed('card-title', true).text('Object').append('button').classed('btn btn-secondary pull-right', true).text('add cone').attr({
          id: 'add-cone'
        });
      }).each(function() {
        return emitter.emit('domAdded', dom);
      });
      return objectControls.exit().remove();
    };
  };

  emitter('unselectObject').flatMap(function(o) {
    var color;
    color = PARENT_SPHERE_COLOR;
    return tweenColor(color)(o);
  }).subscribe(function(update) {
    return emitter.emit('modelUpdate', update);
  });

  tweenColor = function(color) {
    return function(o) {
      var end, i, sphere, start;
      sphere = o;
      start = sphere.material.color;
      end = color;
      i = d3.interpolate(start, end);
      return tweenStream(500, 'color').map(function(t) {
        sphere.material.color = i(t);
        return function(model) {
          return model;
        };
      });
    };
  };

  o = emitter('selectObject');

  m = emitter('modelState');

  emitter('editSelected').withLatestFrom(o, m, function(e, o, m) {
    return [o, m];
  }).map(function(arr) {
    var camera, i, object, update;
    object = arr[0], model = arr[1];
    camera = model.camera;
    i = {
      lookAt: d3.interpolate(camera._lookAt, object.position),
      zoom: d3.interpolate(camera.zoom, EDIT_MODE_ZOOM),
      phi: d3.interpolate(camera.position._polar.phi, degToRad(EDIT_MODE_PHI))
    };
    update = function(t) {
      return function(c) {
        var polar, position;
        position = c.position;
        polar = position._polar;
        polar.phi = i.phi(t);
        position._relative = polarToVector(polar);
        c._lookAt.copy(i.lookAt(t));
        position.addVectors(position._relative, c._lookAt);
        c.zoom = i.zoom(t);
        c.lookAt(c._lookAt);
        c.updateProjectionMatrix();
        return c;
      };
    };
    return update;
  }).subscribe(function(update) {
    return emitter.emit('tweenCamera', {
      update: update,
      duration: 500
    });
  });

  emitter('tweenInSphere').subscribe(function(sphere) {
    var currentGeom, end, geomType, i, params, start;
    currentGeom = sphere.geometry;
    geomType = currentGeom.type;
    params = currentGeom.parameters;
    start = params.radius;
    console.log(sphere._volume);
    end = sphere._volume;
    i = {
      radius: d3.interpolate(start, end)
    };
    return tweenStream(500, 'sphere').map(function(t) {
      var newGeom;
      params.radius = i.radius(t);
      newGeom = currentGeom.clone();
      sphere.geometry.dispose();
      sphere.geometry = newGeom;
      return function(model) {
        return model;
      };
    }).subscribe(function(update) {
      return emitter.emit('modelUpdate', update);
    }, function(err) {}, function(done) {
      return emitter.emit('sphereAdded');
    });
  });

  getMouseFrom = function(node) {
    return function(event) {
      event.mouse = d3.mouse(node);
      return event;
    };
  };

  getNdcFromMouse = function(event, ndc) {
    event.ndc = {
      x: ndc.x(event.mouse[0]),
      y: ndc.y(event.mouse[1])
    };
    return event;
  };

  cameraPolarTweenFunc = function(endFunc) {
    return function(camera) {
      var end, interpolator, polarStart, update;
      polarStart = camera.position._polar;
      end = endFunc(camera);
      interpolator = d3.interpolate(polarStart, end);
      update = function(t) {
        return function(c) {
          c.position._polar = interpolator(t);
          c.position._relative = polarToVector(c.position._polar);
          c.position.addVectors(c.position._relative, c._lookAt);
          c.lookAt(c._lookAt);
          return c;
        };
      };
      return update;
    };
  };

  addMain = function(selection) {
    d3.select('html').style({
      height: '100%'
    });
    d3.select('body').style({
      height: '100%'
    });
    return selection.append('main').style({
      width: "80%",
      height: "80%",
      position: 'relative'
    });
  };

  getClientSize = function(element) {
    return {
      width: element.clientWidth,
      height: element.clientHeight
    };
  };

  addSceneControls = function(selection) {
    return selection.append('div').classed('container', true).attr({
      id: 'sceneControls'
    }).style({
      position: 'absolute',
      right: '0',
      top: '1%'
    });
  };
  
  materialIcon = function(text) {
    return "<i class='material-icons' style='display: block'>" + text + "</i>";
  };

  updateNdcDomain = function(s) {
    return function(d) {
      d.x.domain([0, s.width]);
      d.y.domain([0, s.height]);
      return d;
    };
  };

  firstNdcScales = function() {
    return {
      x: d3.scale.linear().range([-1, 1]),
      y: d3.scale.linear().range([1, -1])
    };
  };

  getRoomObject = function(room) {
    var roomObject;
    roomObject = new THREE.Object3D();
    roomObject.name = 'room';
    return roomObject;
  };

  getInitialScene = function(roomObject) {
    var floor, mainObject, scene;
    mainObject = getMainObject();
    floor = getFloor();
    mainObject.add(floor);
    mainObject.add(roomObject);
    scene = new THREE.Scene();
    scene.add(mainObject);
    return scene;
  };

  getMainObject = function() {
    var mainObject;
    mainObject = new THREE.Object3D();
    return mainObject;
  };

  getFloor = function() {
    var FLOOR_GRID_COLOR, FLOOR_SIZE, c, e, floor, floorGeom, floorMat, grid;
    FLOOR_SIZE = 100;
    FLOOR_GRID_COLOR = new THREE.Color(0, 0, 0);
    floorGeom = new THREE.PlaneGeometry(FLOOR_SIZE, FLOOR_SIZE);
    c = 0.46;
    floorMat = new THREE.MeshPhongMaterial({
      color: new THREE.Color(c, c, c),
      side: THREE.DoubleSide,
      depthWrite: false
    });
    e = 0.5;
    floorMat.emissive = new THREE.Color(e, e, e);
    floor = new THREE.Mesh(floorGeom, floorMat);
    floor.name = 'floor';
    floor.rotateX(Math.PI / 2);
    floor.position.setY(-ROOM_SIZE.height / 2);
    grid = new THREE.GridHelper(FLOOR_SIZE / 2, 2);
    grid.rotateX(Math.PI / 2);
    grid.material.transparent = true;
    grid.material.opacity = 0.2;
    grid.material.linewidth = 2;
    grid.material.depthWrite = false;
    floor.add(grid);
    return floor;
  };

  getFirstCamera = function() {
    var c;
    c = new THREE.OrthographicCamera();
    c.zoom = INITIAL_ZOOM;
    c._lookAt = new THREE.Vector3();
    c.position._polar = {
      radius: CAMERA_RADIUS,
      theta: degToRad(INITIAL_THETA),
      phi: degToRad(INITIAL_PHI)
    };
    c.position._relative = polarToVector(c.position._polar);
    c.position.addVectors(c.position._relative, c._lookAt);
    c.lookAt(c._lookAt);
    c.up.copy(new THREE.Vector3(0, 1, 0));
    c.updateProjectionMatrix();
    return c;
  };

  polarToVector = function(o) {
    var phi, radius, theta, x, y, z;
    radius = o.radius, theta = o.theta, phi = o.phi;
    x = radius * Math.cos(theta) * Math.sin(phi);
    y = radius * Math.sin(theta) * Math.sin(phi);
    z = radius * Math.cos(phi);
    return new THREE.Vector3(y, z, x);
  };

  setCameraSize = function(s) {
    return function(c) {
      var ref, ref1;
      ref = [-1, 1].map(function(d) {
        return d * s.width / 2;
      }), c.left = ref[0], c.right = ref[1];
      ref1 = [-1, 1].map(function(d) {
        return d * s.height / 2;
      }), c.bottom = ref1[0], c.top = ref1[1];
      c.updateProjectionMatrix();
      return c;
    };
  };

  tweenStream = function(duration, name) {
    if (duration == null) {
      duration = 0;
    }
    if (name == null) {
      name = 'tween';
    }
    return Rx.Observable.create(function(observer) {
      return d3.select({}).transition().duration(duration).tween(name, function() {
        return function(t) {
          return observer.onNext(t);
        };
      }).each("end", function() {
        return observer.onCompleted();
      });
    });
  };

  firstModel = function() {
    var hemisphere, spotLight;
    m = {};
    m.camera = getFirstCamera();
    window.oldCamera = m.camera;
    m.room = getRoomObject(ROOM_SIZE);
    m.scene = getInitialScene(m.room);
    window.oldScene = m.scene;
    m.floor = m.scene.getObjectByName('floor');
    spotLight = new THREE.SpotLight(0xffffff, 0.95);
    spotLight.position.setY(100);
    spotLight.castShadow = true;
    spotLight.shadowMapWidth = 4000;
    spotLight.shadowMapHeight = 4000;
    spotLight.shadowDarkness = 0.2;
    spotLight.intensity = 1;
    spotLight.exponent = 1;
    m.scene.add(spotLight);
    m.floor.receiveShadow = true;
    hemisphere = new THREE.HemisphereLight(0, 0xffffff, 0.8);
    m.scene.add(hemisphere);
    return m;
  };

  firstDom = function() {
    var main;
    dom = {};
    dom.canvas = d3.select('body').append('canvas').node();
    dom.sceneControls = addSceneControls(d3.select('body'));
    return dom;
  };

  fromD3drag = function(selection) {
    var handler;
    handler = d3.behavior.drag();
    selection.call(handler);
    return fromD3dragHandler(handler);
  };

  fromD3dragHandler = function(drag) {
    return stream.create(function(observer) {
      return drag.on('dragstart', function() {
        return observer.onNext(d3.event);
      }).on('drag', function() {
        return observer.onNext(d3.event);
      }).on('dragend', function() {
        return observer.onNext(d3.event);
      });
    });
  };

  apply = function(o, fn) {
    return fn(o);
  };

  degToRad = d3.scale.linear().domain([0, 360]).range([0, 2 * Math.PI]);

  emitter('mockup').withLatestFrom(emitter('modelState'), function(a, b) {
    return b;
  }).withLatestFrom(dom).subscribe(function(arr) {
    var __camera, __cube, __geometry, __material, __renderer, __scene, _canv, _rend, _room, _scene, _spoof, _zone, big, c, camera, canvas, cloned, coneParent, foo, grid, hemisphere, i, isIpad, lines, little, offsetZ, port, ref, ref1, s, spotLight, ss, wid, x;
    model = arr[0], dom = arr[1];
    console.info('Start mockup.');
    (function() {
      var p, sphere;
      p = new THREE.Vector3(4, 2, 16);
      return sphere = addObjectAtPoint(p, 0.6);
    })();
    isIpad = navigator.userAgent.match(/iPad/i) !== null;

    _spoof = (function() {
      var _trajectory, p, sphere;
      p = new THREE.Vector3(-7, -0.5, 3);
      sphere = addObjectAtPoint(p, 0.7);
      addConeParentWithParams({
        _volume: 2,
        _spread: 0.5,
        _theta: 0,
        _phi: Math.PI / 2
      })(sphere);
      addConeParentWithParams({
        _volume: 1.2,
        _spread: 0.7,
        _theta: Math.PI * 0.3,
        _phi: -Math.PI * 0.1
      })(sphere);
      return sphere;
    })();
    coneParent = _spoof.children[1];
    isIpad = navigator.userAgent.match(/iPad/i) !== null;
    if (!isIpad) {
      highlightObject(coneParent.getObjectByName('cone'));
    }
    if (isIpad === true) {
      _spoof = big;
    }
    wid = dom.sceneControls.node().clientWidth * 0.6;
    if (!isIpad) {
      port = dom.sceneControls.append('div').classed('card', true).style('height', wid + "px");
      _canv = port.append("canvas");
      _rend = new THREE.WebGLRenderer({
        canvas: _canv.node(),
        antialias: true
      });
      _rend.setClearColor('white');
      _scene = new THREE.Scene();
      _rend.setSize(port.node().clientWidth, port.node().clientHeight);
      cloned = _spoof.clone();
      spotLight = new THREE.SpotLight(0xffffff, 0.95);
      spotLight.position.setY(100);
      spotLight.castShadow = true;
      spotLight.shadowMapWidth = 4000;
      spotLight.shadowMapHeight = 4000;
      spotLight.shadowDarkness = 0.001;
      hemisphere = new THREE.HemisphereLight(0, 0xffffff, 0.8);
      _scene.add(hemisphere);
      _scene.add(spotLight);
      c = new THREE.OrthographicCamera();
      c.zoom = INITIAL_ZOOM * 1.5;
      c._lookAt = new THREE.Vector3();
      c.position._polar = {
        radius: CAMERA_RADIUS,
        theta: degToRad(INITIAL_THETA),
        phi: degToRad(INITIAL_PHI)
      };
      c.position._relative = polarToVector(c.position._polar);
      c.position.addVectors(c.position._relative, c._lookAt);
      c.lookAt(cloned.position);
      c.up.copy(new THREE.Vector3(0, 1, 0));
      s = {
        width: port.node().clientWidth,
        height: port.node().clientHeight
      };
      ref = [-1, 1].map(function(d) {
        return d * s.width / 2;
      }), c.left = ref[0], c.right = ref[1];
      ref1 = [-1, 1].map(function(d) {
        return d * s.height / 2;
      }), c.bottom = ref1[0], c.top = ref1[1];
      c.updateProjectionMatrix();
      camera = c;
      _scene.add(cloned);
      i = 0;
      d3.timer(function() {
        var sc;
        i++;
        sc = new THREE.Scene();
        sc.add(spotLight);
        cloned = _spoof.clone();
        cloned.remove(cloned.children[0]);
        cloned.remove(cloned.children[2]);
        cloned.rotateY(degToRad(45));
        sc.add(cloned);
        _rend.render(sc, camera);
        if (i === 40) {
          return true;
        }
        return false;
      });
    }
  });

  console.log('test');

  emitter.emit('start');

  emitter.emit('mockup');


function newVersion() {
  const container = d3.select('body')
    .append('div')
    .attr('id', 'new')
    .style({
      position: 'relative'
    })
  
  const main_canvas = container
    .append('canvas')
    .attr('id', 'main-canvas')
    .style({
      border: '1px solid black'
    });
    
  const editor_container = container
    .append('div')
    .classed('container', true)
    .attr('id', 'editor')
    .style({
      position: 'absolute', right: '0px', top: '1%',
      border: '1px solid green'
    })
    
  const editor_canvas = editor_container
    .append('canvas')
    .attr('id', 'editor-canvas')
    .style({
      border: '1px solid blue'
    });
    
  const main_renderer = new THREE.WebGLRenderer({
    canvas: main_canvas.node(),
    antialias: true
  });
  main_renderer.setSize(500, 500);
  main_renderer.shadowMap.enabled = true;
  main_renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  
  const new_scene = new THREE.Scene();
  
  main_renderer.render(window.oldScene, window.oldCamera);
}

setTimeout(() => newVersion(), 500);
