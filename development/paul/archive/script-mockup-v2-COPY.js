// Generated by CoffeeScript 1.10.0
(function() {
  var CAMERA_RADIUS, CONE_BOTTOM, DEFAULT_CONE_SPREAD, DEFAULT_OBJECT_HEIGHT, DEFAULT_OBJECT_VOLUME, EDIT_MODE_PHI, EDIT_MODE_ZOOM, INITIAL_PHI, INITIAL_THETA, INITIAL_ZOOM, MAX_CONE_SPREAD, MAX_CONE_VOLUME, MAX_PHI, MIN_PHI, PARENT_SPHERE_COLOR, ROOM_SIZE, ZOOM_AMOUNT, _canvasDragEnd, _canvasDragStart, addCameraControls, addCone, addConeParentWithParams, addMain, addObjectAtPoint, addObjectMode, addSceneControls, allIntersects, apply, cameraPolarTweenFunc, cameraSize, canvasDrag, canvasDragEnd, canvasDragMove, canvasDragStart, degToRad, dom, emitter, f, firstDom, firstModel, firstNdcScales, fromD3drag, fromD3dragHandler, getClientSize, getConeParentWithParams, getFirstCamera, getFloor, getInitialScene, getMainObject, getModeButtons, getMouseFrom, getNdcFromMouse, getRoomObject, highlightObject, log, m, materialIcon, model, modelUpdates, ndc, o, polarToVector, r, raycaster, readyAdd, renderer, setCameraSize, size, stream, tweenColor, tweenStream, updateConeControls, updateConeParent, updateNdcDomain, updateObjectControls;

  Rx.config.longStackSupport = true;

  stream = Rx.Observable;

  raycaster = new THREE.Raycaster();

  log = console.log.bind(console);

  CAMERA_RADIUS = 100;

  INITIAL_THETA = 80;

  INITIAL_PHI = 45;

  INITIAL_ZOOM = 40;

  MIN_PHI = 0.01;

  MAX_PHI = Math.PI * 0.5;

  EDIT_MODE_ZOOM = 90;

  EDIT_MODE_PHI = 85;

  ZOOM_AMOUNT = 2;

  DEFAULT_OBJECT_HEIGHT = 0;

  PARENT_SPHERE_COLOR = new THREE.Color(0, 0, 0);

  ROOM_SIZE = {
    width: 20,
    length: 18,
    height: 3
  };

  DEFAULT_OBJECT_VOLUME = 1;

  DEFAULT_CONE_SPREAD = 0.3;

  MAX_CONE_SPREAD = 2;

  MAX_CONE_VOLUME = 2;

  CONE_BOTTOM = 0.01;

  emitter = (function() {
    var _emitter, subject;
    subject = new Rx.Subject();
    _emitter = function(event) {
      return subject.filter(function(o) {
        return o.event === event;
      }).map(function(o) {
        return o.data;
      });
    };
    _emitter.emit = function(event, data) {
      return subject.onNext({
        event: event,
        data: data
      });
    };
    return _emitter;
  })();

  dom = emitter('start').flatMap(function() {
    return stream.just(firstDom());
  }).shareReplay();

  size = stream.fromEvent(window, 'resize').startWith('first resize').combineLatest(dom, function(a, b) {
    return b;
  }).map(function(dom) {
    return getClientSize(dom.main.node());
  });

  ndc = emitter('start').flatMap(function() {
    return size.map(updateNdcDomain).scan(apply, firstNdcScales());
  });

  cameraSize = size.map(function(size) {
    return function(model) {
      model.camera = setCameraSize(size)(model.camera);
      return model;
    };
  });

  renderer = dom.flatMap(function(dom) {
    var first;
    first = new THREE.WebGLRenderer({
      canvas: dom.canvas,
      antialias: true
    });
    first.shadowMap.enabled = true;
    first.shadowMap.type = THREE.PCFSoftShadowMap;
    return size.scan(function(r, s) {
      r.setSize(s.width, s.height);
      return r;
    }, first);
  });

  emitter('tweenCamera').flatMap(function(o) {
    return tweenStream(o.duration).map(o.update);
  }).map(function(update) {
    return function(model) {
      model.camera = update(model.camera);
      return model;
    };
  }).subscribe(function(update) {
    return emitter.emit('modelUpdate', update);
  });

  modelUpdates = stream.merge(cameraSize, emitter('modelUpdate'));

  model = emitter('start').flatMap(function() {
    return modelUpdates.scan(function(o, fn) {
      emitter.emit('modelState', o);
      return fn(o);
    }, firstModel());
  });

  (function() {
    var onError, onNext;
    onNext = function(arr) {
      model = arr[0], renderer = arr[1];
      return renderer.render(model.scene, model.camera);
    };
    onError = function(err) {
      return console.error(err.stack);
    };
    return model.combineLatest(renderer).subscribe(onNext, onError);
  })();

  canvasDrag = dom.flatMap(function(dom) {
    var canvas;
    canvas = dom.canvas;
    return fromD3drag(d3.select(canvas)).map(getMouseFrom(canvas));
  }).withLatestFrom(ndc, function(a, b) {
    return getNdcFromMouse(a, b);
  }).withLatestFrom(emitter('modelState'))["do"](function(arr) {
    var event, floorIntersects, roomIntersects;
    event = arr[0], model = arr[1];
    raycaster.setFromCamera(event.ndc, model.camera);
    roomIntersects = raycaster.intersectObjects(model.room.children, true);
    floorIntersects = raycaster.intersectObject(model.floor, false);
    emitter.emit('roomIntersects', roomIntersects);
    return emitter.emit('floorIntersects', floorIntersects);
  }).map(function(arr) {
    return arr[0];
  }).subscribe(function(d) {
    return emitter.emit('canvasDrag', d);
  });

  r = emitter('roomIntersects');

  f = emitter('floorIntersects');

  allIntersects = stream.combineLatest(r, f, (function(r, f) {
    return {
      room: r,
      floor: f
    };
  }));

  _canvasDragStart = emitter('canvasDrag').filter(function(e) {
    return e.type === 'dragstart';
  });

  _canvasDragEnd = emitter('canvasDrag').filter(function(e) {
    return e.type === 'dragend';
  });

  canvasDragStart = emitter('canvasDrag').filter(function(e) {
    return e.type === 'dragstart';
  }).withLatestFrom(allIntersects, function(e, i) {
    return i;
  });

  canvasDragMove = emitter('canvasDrag').filter(function(e) {
    return e.type === 'drag';
  }).withLatestFrom(allIntersects, function(e, i) {
    return i;
  });

  canvasDragEnd = emitter('canvasDrag').filter(function(e) {
    return e.type === 'dragend';
  }).withLatestFrom(allIntersects, function(e, i) {
    return i;
  });

  addObjectMode = dom.flatMap(function(dom) {
    var addObject;
    addObject = dom.modeButtons.select('#object').node();
    return stream.fromEvent(addObject, 'click');
  });

  readyAdd = addObjectMode.map(function() {
    return true;
  }).merge(emitter('cancelAdd').map(function() {
    return false;
  })).startWith(false)["do"](function(d) {
    return log("readyAdd " + d);
  });

  canvasDragStart.withLatestFrom(readyAdd).filter(function(arr) {
    return arr[1] === true;
  }).subscribe(function(arr) {
    var event, ready;
    event = arr[0], ready = arr[1];
    console.info('Adding object.');
    return emitter.emit('addObject', event);
  });

  canvasDragEnd.withLatestFrom(readyAdd).filter(function(arr) {
    return arr[1] === true;
  }).subscribe(function(arr) {
    return emitter.emit('cancelAdd');
  });

  _canvasDragEnd.withLatestFrom(_canvasDragStart).filter(function(arr) {
    var xEqual, yEqual;
    xEqual = arr[0].mouse[0] === arr[1].mouse[0];
    yEqual = arr[0].mouse[1] === arr[1].mouse[1];
    return xEqual && yEqual;
  }).map(function(arr) {
    return arr[0];
  }).subscribe(function(event) {
    return emitter.emit('click', event);
  });

  emitter('click').withLatestFrom(allIntersects, function(e, i) {
    return i;
  }).withLatestFrom(readyAdd).filter(function(arr) {
    return arr[1] === false;
  }).map(function(arr) {
    return arr[0];
  }).filter(function(i) {
    return i.room.length > 0;
  }).subscribe(function(i) {});

  emitter('click').withLatestFrom(allIntersects, function(e, i) {
    return i;
  }).pausable(readyAdd.map(function(d) {
    return !d;
  })).filter(function(i) {
    return i.room.length === 0;
  })["do"](function() {
    return console.log('clicked floor');
  }).subscribe(function() {
    return emitter.emit('unselectAll');
  });

  emitter('unselectAll').subscribe(function(i) {
    return emitter.emit('unselectOthers', {});
  });

  canvasDragMove.withLatestFrom(readyAdd).filter(function(arr) {
    return arr[1] === false;
  }).map(function(arr) {
    return arr[0];
  }).withLatestFrom(canvasDragStart).filter(function(arr) {
    return arr[1].room[0] == null;
  }).map(function(arr) {
    var _current, _start, current, delta, ref, ref1, start, update;
    current = arr[0], start = arr[1];
    _current = ((ref = current.floor[0]) != null ? ref.point : void 0) || (new THREE.Vector3());
    _start = ((ref1 = start.floor[0]) != null ? ref1.point : void 0) || _current;
    delta = (new THREE.Vector3()).subVectors(_start, _current);
    update = function(model) {
      model.camera._lookAt.add(delta);
      model.camera.position.add(delta);
      return model;
    };
    return update;
  }).subscribe(function(update) {
    return emitter.emit('modelUpdate', update);
  });

  canvasDragStart.withLatestFrom(readyAdd).filter(function(arr) {
    return arr[1] === false;
  }).map(function(arr) {
    return arr[0];
  }).filter(function(start) {
    return start.room[0] != null;
  }).flatMap(function(start) {
    return canvasDragMove.startWith(start).filter(function(ints) {
      return ints.floor[0] != null;
    }).map(function(ints) {
      var ref;
      return (ref = ints.floor[0]) != null ? ref.point : void 0;
    }).bufferWithCount(2, 1).takeUntil(canvasDragEnd);
  }).map(function(arr) {
    return (new THREE.Vector3()).subVectors(arr[1], arr[0]);
  }).withLatestFrom(canvasDragStart).map(function(arr) {
    var delta, int, obj;
    delta = arr[0], int = arr[1];
    delta.setY(0);
    obj = int.room[0].object;
    return function(model) {
      obj.position.add(delta);
      console.log(obj.position);
      return model;
    };
  }).subscribe(function(update) {
    return emitter.emit('modelUpdate', update);
  });

  dom.flatMap(function(dom) {
    var cameraMove;
    cameraMove = dom.miniCube;
    return fromD3drag(cameraMove);
  }).filter(function(e) {
    return e.type === 'drag';
  }).map(function(e) {
    return function(camera) {
      var polar;
      polar = camera.position._polar;
      polar.phi += degToRad(e.dy);
      polar.theta += degToRad(e.dx);
      if (polar.phi < MIN_PHI) {
        polar.phi = MIN_PHI;
      }
      if (polar.phi > MAX_PHI) {
        polar.phi = MAX_PHI;
      }
      camera.position._relative = polarToVector(camera.position._polar);
      camera.position.addVectors(camera.position._relative, camera._lookAt);
      camera.lookAt(camera._lookAt);
      return camera;
    };
  }).subscribe(function(camUpdate) {
    var update;
    update = function(model) {
      model.camera = camUpdate(model.camera);
      return model;
    };
    return emitter.emit('modelUpdate', update);
  });

  dom.flatMap(function(dom) {
    var a, zooms;
    a = ZOOM_AMOUNT;
    zooms = [['Out', 1 / a], ['In', a]].map(function(arr) {
      var node;
      node = dom.cameraControls.select("#zoom" + arr[0]).node();
      return stream.fromEvent(node, 'click').map(function() {
        return arr[1];
      });
    });
    return stream.merge(zooms);
  }).subscribe(function(dz) {
    return emitter.emit('zoom', dz);
  });

  emitter('zoom').withLatestFrom(emitter('modelState')).map(function(arr) {
    var camera, dz, interpolator, update, z;
    dz = arr[0], model = arr[1];
    camera = model.camera;
    z = camera.zoom;
    interpolator = d3.interpolate(z, z * dz);
    update = function(t) {
      return function(c) {
        c.zoom = interpolator(t);
        c.updateProjectionMatrix();
        return c;
      };
    };
    return update;
  }).subscribe(function(update) {
    return emitter.emit('tweenCamera', {
      update: update,
      duration: 500
    });
  });

  addObjectMode.withLatestFrom(emitter('modelState'), function(a, b) {
    return b;
  }).subscribe(function(model) {
    var camera, currentPhi, endFunc, i, maxPhi, updatePhi, updateZoom;
    camera = model.camera;
    currentPhi = camera.position._polar.phi;
    maxPhi = degToRad(EDIT_MODE_PHI);
    if (currentPhi > maxPhi) {
      endFunc = function() {
        return {
          phi: maxPhi
        };
      };
      updatePhi = cameraPolarTweenFunc(endFunc)(camera);
      emitter.emit('tweenCamera', {
        update: updatePhi,
        duration: 500
      });
    }
    if (camera.zoom !== INITIAL_ZOOM) {
      i = d3.interpolate(camera.zoom, INITIAL_ZOOM);
      updateZoom = function(t) {
        return function(c) {
          c.zoom = i(t);
          c.updateProjectionMatrix();
          return c;
        };
      };
      return emitter.emit('tweenCamera', {
        update: updateZoom,
        duration: 500
      });
    }
  });

  emitter('addObject').withLatestFrom(emitter('floorIntersects')).subscribe(function(arr) {
    var event, intersects, p, ref;
    event = arr[0], intersects = arr[1];
    p = (ref = intersects[0]) != null ? ref.point : void 0;
    return addObjectAtPoint(p);
  });

  addObjectAtPoint = function(p, volume) {
    var _lineBottom, geometry, line, lineGeom, mat, material, object, s, sphere, update, y;
    console.info("Add object at", p);
    geometry = new THREE.SphereGeometry(0.1, 30, 30);
    material = new THREE.MeshPhongMaterial({
      color: PARENT_SPHERE_COLOR,
      transparent: true,
      opacity: 0.3,
      side: THREE.DoubleSide
    });
    sphere = new THREE.Mesh(geometry, material);
    sphere.castShadow = true;
    sphere.receiveShadow = true;
    sphere.name = 'parentSphere';
    sphere._volume = volume || 1;
    sphere.renderOrder = 10;
    lineGeom = new THREE.Geometry();
    _lineBottom = -p.y + (-ROOM_SIZE.height / 2);
    lineGeom.vertices.push(new THREE.Vector3(0, _lineBottom, 0));
    lineGeom.vertices.push(new THREE.Vector3(0, 100, 0));
    lineGeom.computeLineDistances();
    s = 0.3;
    mat = new THREE.LineDashedMaterial({
      color: 0,
      linewidth: 1,
      dashSize: s,
      gapSize: s,
      transparent: true,
      opacity: 0.2
    });
    line = new THREE.Line(lineGeom, mat);
    sphere.add(line);
    object = sphere;
    DEFAULT_OBJECT_HEIGHT = 1;
    y = DEFAULT_OBJECT_HEIGHT;
    object.position.copy(p);
    update = function(model) {
      var i;
      i = model.room.children.length;
      object.name = "object" + i;
      object._id = i;
      model.room.add(object);
      return model;
    };
    emitter.emit('modelUpdate', update);
    emitter.emit('tweenInSphere', sphere);
    emitter.emit('objectAdded', object);
    return object;
  };

  emitter('objectAdded').subscribe(function(o) {});

  highlightObject = function(o) {
    var color;
    color = new THREE.Color("#99ebff");
    color = new THREE.Color("#66c2ff");
    return tweenColor(color)(o).subscribe(function(up) {
      return emitter.emit('modelUpdate', function(m) {
        return m;
      });
    });
  };

  emitter('selectObject')["do"](function(o) {
    return emitter.emit('unselectOthers', o);
  }).flatMap(function(o) {
    var color;
    color = new THREE.Color(0, 0, 1);
    return tweenColor(color)(o);
  }).subscribe(function(update) {
    return emitter.emit('modelUpdate', update);
  });

  emitter('selectObject').withLatestFrom(dom).subscribe(function(arr) {
    var object;
    object = arr[0], dom = arr[1];
    return updateObjectControls(dom)([object]);
  });

  emitter('unselectAll').withLatestFrom(dom, function(a, b) {
    return b;
  }).subscribe(function(dom) {
    return updateObjectControls(dom)([]);
  });

  addCone = emitter('domAdded').map(function(dom) {
    return dom.sceneControls.select('#add-cone').node();
  }).filter(function(node) {
    return node != null;
  }).flatMap(function(node) {
    return stream.fromEvent(node, 'click');
  })["do"](function() {
    return console.info('Add cone.');
  }).subscribe(function(event) {
    var obj;
    obj = d3.select(event.target).datum();
    console.log(obj);
    return emitter.emit('addCone', obj);
  });

  emitter('coneAdded').subscribe(function(coneParent) {
    return emitter.emit('selectCone', coneParent);
  });

  emitter('selectCone').withLatestFrom(dom).subscribe(function(arr) {
    var object;
    object = arr[0], dom = arr[1];
    return updateConeControls(dom)([object]);
  });

  getConeParentWithParams = function(params) {
    var CONE_RADIAL_SEGMENTS, cone, coneParent, geometry, material;
    coneParent = new THREE.Object3D();
    Object.assign(coneParent, params);
    coneParent.castShadow = true;
    coneParent.receiveShadow = true;
    CONE_RADIAL_SEGMENTS = 50;
    geometry = new THREE.CylinderGeometry();
    geometry.parameters = {
      radiusBottom: CONE_BOTTOM,
      openEnded: true,
      radialSegments: CONE_RADIAL_SEGMENTS
    };
    geometry = geometry.clone();
    material = new THREE.MeshPhongMaterial({
      transparent: true,
      opacity: 0.5,
      side: THREE.DoubleSide
    });
    cone = new THREE.Mesh(geometry, material);
    cone.name = 'cone';
    cone.castShadow = true;
    cone.renderOrder = 1;
    cone.receiveShadow = true;
    coneParent.add(cone);
    return coneParent;
  };

  addConeParentWithParams = function(params) {
    return function(obj) {
      var coneParent, i;
      coneParent = getConeParentWithParams(params);
      updateConeParent(coneParent);
      i = obj.children.length;
      coneParent.name = "cone" + i;
      return obj.add(coneParent);
    };
  };

  emitter('addCone').subscribe(function(obj) {
    var params;
    params = {
      _theta: Math.random() * (Math.PI * 2),
      _phi: Math.random() * (Math.PI * 2),
      _volume: DEFAULT_OBJECT_VOLUME,
      _spread: DEFAULT_CONE_SPREAD
    };
    addConeParentWithParams(params)(obj);
    return emitter.emit('modelUpdate', function(m) {
      return m;
    });
  });

  updateConeParent = function(coneParent) {
    var cone, geom, newGeom, params;
    coneParent.rotation.x = coneParent._phi;
    coneParent.rotation.z = coneParent._theta;
    cone = coneParent.getObjectByName('cone');
    geom = cone.geometry;
    params = geom.parameters;
    params.height = coneParent._volume;
    params.radiusTop = coneParent._spread;
    newGeom = geom.clone();
    cone.geometry.dispose();
    cone.geometry = newGeom;
    return cone.position.y = cone.geometry.parameters.height / 2;
  };

  emitter('coneParentUpdate').subscribe(function(coneParent) {
    updateConeParent(coneParent);
    return emitter.emit('modelUpdate', function(m) {
      return m;
    });
  });

  window.emitter = emitter;

  updateConeControls = function(dom) {
    return function(data) {
      var coneControls;
      coneControls = dom.sceneControls.select("#objectControls").select(".card").selectAll("#coneControls").data(data);
      coneControls.enter().append('div').attr({
        id: "coneControls"
      }).call(function(card) {
        return card.append('div').classed('card-block', true).append('h4').classed('card-title', true).text('Cone').append('button').classed('btn btn-secondary pull-right', true).text('add file');
      });
      return coneControls.exit().remove();
    };
  };

  updateObjectControls = function(dom) {
    return function(data) {
      var objectControls;
      objectControls = dom.sceneControls.selectAll("#objectControls").data(data);
      objectControls.enter().append('div').classed('row', true).attr({
        id: 'objectControls'
      }).append('div').classed('col-xs-12', true).append('div').classed('card', true).call(function(card) {
        return card.append('div').classed('card-block', true).append('h4').classed('card-title', true).text('Object').append('button').classed('btn btn-secondary pull-right', true).text('add cone').attr({
          id: 'add-cone'
        });
      }).each(function() {
        return emitter.emit('domAdded', dom);
      });
      return objectControls.exit().remove();
    };
  };

  emitter('unselectObject').flatMap(function(o) {
    var color;
    color = PARENT_SPHERE_COLOR;
    return tweenColor(color)(o);
  }).subscribe(function(update) {
    return emitter.emit('modelUpdate', update);
  });

  tweenColor = function(color) {
    return function(o) {
      var end, i, sphere, start;
      sphere = o;
      start = sphere.material.color;
      end = color;
      i = d3.interpolate(start, end);
      return tweenStream(500, 'color').map(function(t) {
        sphere.material.color = i(t);
        return function(model) {
          return model;
        };
      });
    };
  };

  emitter('unselectOthers').withLatestFrom(emitter('modelState')).subscribe(function(arr) {
    var chil, obj;
    obj = arr[0], model = arr[1];
    chil = model.room.children;
    return _.without(chil, obj).forEach(function(o) {
      return emitter.emit('unselectObject', o);
    });
  });

  o = emitter('selectObject');

  m = emitter('modelState');

  emitter('editSelected').withLatestFrom(o, m, function(e, o, m) {
    return [o, m];
  }).map(function(arr) {
    var camera, i, object, update;
    object = arr[0], model = arr[1];
    camera = model.camera;
    i = {
      lookAt: d3.interpolate(camera._lookAt, object.position),
      zoom: d3.interpolate(camera.zoom, EDIT_MODE_ZOOM),
      phi: d3.interpolate(camera.position._polar.phi, degToRad(EDIT_MODE_PHI))
    };
    update = function(t) {
      return function(c) {
        var polar, position;
        position = c.position;
        polar = position._polar;
        polar.phi = i.phi(t);
        position._relative = polarToVector(polar);
        c._lookAt.copy(i.lookAt(t));
        position.addVectors(position._relative, c._lookAt);
        c.zoom = i.zoom(t);
        c.lookAt(c._lookAt);
        c.updateProjectionMatrix();
        return c;
      };
    };
    return update;
  }).subscribe(function(update) {
    return emitter.emit('tweenCamera', {
      update: update,
      duration: 500
    });
  });

  emitter('tweenInSphere').subscribe(function(sphere) {
    var currentGeom, end, geomType, i, params, start;
    currentGeom = sphere.geometry;
    geomType = currentGeom.type;
    params = currentGeom.parameters;
    start = params.radius;
    console.log(sphere._volume);
    end = sphere._volume;
    i = {
      radius: d3.interpolate(start, end)
    };
    return tweenStream(500, 'sphere').map(function(t) {
      var newGeom;
      params.radius = i.radius(t);
      newGeom = currentGeom.clone();
      sphere.geometry.dispose();
      sphere.geometry = newGeom;
      return function(model) {
        return model;
      };
    }).subscribe(function(update) {
      return emitter.emit('modelUpdate', update);
    }, function(err) {}, function(done) {
      return emitter.emit('sphereAdded');
    });
  });

  getMouseFrom = function(node) {
    return function(event) {
      event.mouse = d3.mouse(node);
      return event;
    };
  };

  getNdcFromMouse = function(event, ndc) {
    event.ndc = {
      x: ndc.x(event.mouse[0]),
      y: ndc.y(event.mouse[1])
    };
    return event;
  };

  cameraPolarTweenFunc = function(endFunc) {
    return function(camera) {
      var end, interpolator, polarStart, update;
      polarStart = camera.position._polar;
      end = endFunc(camera);
      interpolator = d3.interpolate(polarStart, end);
      update = function(t) {
        return function(c) {
          c.position._polar = interpolator(t);
          c.position._relative = polarToVector(c.position._polar);
          c.position.addVectors(c.position._relative, c._lookAt);
          c.lookAt(c._lookAt);
          return c;
        };
      };
      return update;
    };
  };

  addMain = function(selection) {
    d3.select('html').style({
      height: '100%'
    });
    d3.select('body').style({
      height: '100%'
    });
    return selection.append('main').style({
      width: "100%",
      height: "100%",
      position: 'relative'
    });
  };

  getClientSize = function(element) {
    return {
      width: element.clientWidth,
      height: element.clientHeight
    };
  };

  addSceneControls = function(selection) {
    selection.append('div').classed('container', true).attr({
      id: 'fileControls'
    }).style({
      position: 'absolute',
      left: 0,
      top: '1%'
    }).append('div').classed('row', true).append('div').classed('col-xs-12', true).style({
      'margin-top': '-12px'
    }).append('div').classed('btn-group file', true).call(function(group) {
      var btns;
      btns = ['<i class="material-icons" style="display: block">volume_up</i>', '<i class="material-icons" style="display: block">save</i>', '<i class="material-icons" style="display: block">open_in_browser</i>'];
      return group.selectAll('button').data(btns).enter().append('button').classed('btn btn-lg btn-secondary', true).html(function(d) {
        return d;
      });
    });
    return selection.append('div').classed('container', true).attr({
      id: 'sceneControls'
    }).style({
      position: 'absolute',
      right: '0',
      top: '1%'
    });
  };

  getModeButtons = function(sceneControls) {
    var butts;
    butts = [
      {
        name: 'object',
        html: '<i class="material-icons" style="display: block">add</i>'
      }
    ];
    return sceneControls.append('div').classed('row', true).append('div').classed('col-xs-12', true).style({
      'margin-top': '-12px'
    }).append('div').classed('btn-group modes pull-right', true).call(function(group) {
      return group.selectAll('button').data(butts).enter().append('button').classed('btn btn-lg btn-primary', true).attr('id', function(d) {
        return d.name;
      }).html(function(d) {
        var ref;
        return (ref = d.html) != null ? ref : d.name;
      });
    });
  };

  addCameraControls = function(main) {
    var buttons, butts, cameraControls;
    cameraControls = main.append('div').classed('container', true).style({
      position: 'absolute',
      right: '0',
      bottom: '1%'
    }).append('div').classed('row', true).append('div').classed('col-xs-12', true).append('div').classed("cameraControls", true);
    buttons = [
      {
        name: "zoomOut",
        html: materialIcon('zoom_out')
      }, {
        name: "zoomIn",
        html: materialIcon('zoom_in')
      }
    ];
    butts = cameraControls.selectAll("button").data(buttons);
    butts.enter().append("button").classed("btn btn-secondary", true).attr("id", function(d) {
      return d.name;
    }).html(function(d) {
      var ref;
      return (ref = d.html) != null ? ref : d.name;
    });
    return cameraControls;
  };

  materialIcon = function(text) {
    return "<i class='material-icons' style='display: block'>" + text + "</i>";
  };

  updateNdcDomain = function(s) {
    return function(d) {
      d.x.domain([0, s.width]);
      d.y.domain([0, s.height]);
      return d;
    };
  };

  firstNdcScales = function() {
    return {
      x: d3.scale.linear().range([-1, 1]),
      y: d3.scale.linear().range([1, -1])
    };
  };

  getRoomObject = function(room) {
    var roomObject;
    roomObject = new THREE.Object3D();
    roomObject.name = 'room';
    return roomObject;
  };

  getInitialScene = function(roomObject) {
    var floor, mainObject, scene;
    mainObject = getMainObject();
    floor = getFloor();
    mainObject.add(floor);
    mainObject.add(roomObject);
    scene = new THREE.Scene();
    scene.add(mainObject);
    return scene;
  };

  getMainObject = function() {
    var mainObject;
    mainObject = new THREE.Object3D();
    return mainObject;
  };

  getFloor = function() {
    var FLOOR_GRID_COLOR, FLOOR_SIZE, c, e, floor, floorGeom, floorMat, grid;
    FLOOR_SIZE = 100;
    FLOOR_GRID_COLOR = new THREE.Color(0, 0, 0);
    floorGeom = new THREE.PlaneGeometry(FLOOR_SIZE, FLOOR_SIZE);
    c = 0.46;
    floorMat = new THREE.MeshPhongMaterial({
      color: new THREE.Color(c, c, c),
      side: THREE.DoubleSide,
      depthWrite: false
    });
    e = 0.5;
    floorMat.emissive = new THREE.Color(e, e, e);
    floor = new THREE.Mesh(floorGeom, floorMat);
    floor.name = 'floor';
    floor.rotateX(Math.PI / 2);
    floor.position.setY(-ROOM_SIZE.height / 2);
    grid = new THREE.GridHelper(FLOOR_SIZE / 2, 2);
    grid.rotateX(Math.PI / 2);
    grid.material.transparent = true;
    grid.material.opacity = 0.2;
    grid.material.linewidth = 2;
    grid.material.depthWrite = false;
    floor.add(grid);
    return floor;
  };

  getFirstCamera = function() {
    var c;
    c = new THREE.OrthographicCamera();
    c.zoom = INITIAL_ZOOM;
    c._lookAt = new THREE.Vector3();
    c.position._polar = {
      radius: CAMERA_RADIUS,
      theta: degToRad(INITIAL_THETA),
      phi: degToRad(INITIAL_PHI)
    };
    c.position._relative = polarToVector(c.position._polar);
    c.position.addVectors(c.position._relative, c._lookAt);
    c.lookAt(c._lookAt);
    c.up.copy(new THREE.Vector3(0, 1, 0));
    c.updateProjectionMatrix();
    return c;
  };

  polarToVector = function(o) {
    var phi, radius, theta, x, y, z;
    radius = o.radius, theta = o.theta, phi = o.phi;
    x = radius * Math.cos(theta) * Math.sin(phi);
    y = radius * Math.sin(theta) * Math.sin(phi);
    z = radius * Math.cos(phi);
    return new THREE.Vector3(y, z, x);
  };

  setCameraSize = function(s) {
    return function(c) {
      var ref, ref1;
      ref = [-1, 1].map(function(d) {
        return d * s.width / 2;
      }), c.left = ref[0], c.right = ref[1];
      ref1 = [-1, 1].map(function(d) {
        return d * s.height / 2;
      }), c.bottom = ref1[0], c.top = ref1[1];
      c.updateProjectionMatrix();
      return c;
    };
  };

  tweenStream = function(duration, name) {
    if (duration == null) {
      duration = 0;
    }
    if (name == null) {
      name = 'tween';
    }
    return Rx.Observable.create(function(observer) {
      return d3.select({}).transition().duration(duration).tween(name, function() {
        return function(t) {
          return observer.onNext(t);
        };
      }).each("end", function() {
        return observer.onCompleted();
      });
    });
  };

  firstModel = function() {
    var hemisphere, spotLight;
    m = {};
    m.camera = getFirstCamera();
    m.room = getRoomObject(ROOM_SIZE);
    m.scene = getInitialScene(m.room);
    m.floor = m.scene.getObjectByName('floor');
    spotLight = new THREE.SpotLight(0xffffff, 0.95);
    spotLight.position.setY(100);
    spotLight.castShadow = true;
    spotLight.shadowMapWidth = 4000;
    spotLight.shadowMapHeight = 4000;
    spotLight.shadowDarkness = 0.2;
    spotLight.intensity = 1;
    spotLight.exponent = 1;
    m.scene.add(spotLight);
    m.floor.receiveShadow = true;
    hemisphere = new THREE.HemisphereLight(0, 0xffffff, 0.8);
    m.scene.add(hemisphere);
    return m;
  };

  firstDom = function() {
    var main;
    dom = {};
    dom.main = main = addMain(d3.select('body'));
    dom.miniCube = dom.main.append("canvas").attr('id', 'miniCube').style({
      position: 'absolute',
      bottom: '31px',
      right: '21px'
    });
    dom.canvas = main.append('canvas').node();
    dom.sceneControls = addSceneControls(main);
    dom.modeButtons = getModeButtons(dom.sceneControls);
    dom.cameraControls = addCameraControls(main);
    return dom;
  };

  fromD3drag = function(selection) {
    var handler;
    handler = d3.behavior.drag();
    selection.call(handler);
    return fromD3dragHandler(handler);
  };

  fromD3dragHandler = function(drag) {
    return stream.create(function(observer) {
      return drag.on('dragstart', function() {
        return observer.onNext(d3.event);
      }).on('drag', function() {
        return observer.onNext(d3.event);
      }).on('dragend', function() {
        return observer.onNext(d3.event);
      });
    });
  };

  apply = function(o, fn) {
    return fn(o);
  };

  degToRad = d3.scale.linear().domain([0, 360]).range([0, 2 * Math.PI]);

  emitter('mockup').withLatestFrom(emitter('modelState'), function(a, b) {
    return b;
  }).withLatestFrom(dom).subscribe(function(arr) {
    var __camera, __cube, __geometry, __material, __renderer, __scene, _canv, _rend, _room, _scene, _spoof, _zone, big, c, camera, canvas, cloned, coneParent, foo, grid, hemisphere, i, isIpad, lines, little, offsetZ, port, ref, ref1, s, spotLight, ss, wid, x;
    model = arr[0], dom = arr[1];
    console.info('Start mockup.');
    (function() {
      var p, sphere;
      p = new THREE.Vector3(4, 2, 16);
      return sphere = addObjectAtPoint(p, 0.6);
    })();
    big = (function() {
      var p, sphere;
      p = new THREE.Vector3(-3, 2.5, -4);
      sphere = addObjectAtPoint(p, 1.2);
      addConeParentWithParams({
        _volume: 2,
        _spread: 0.2,
        _theta: degToRad(-60),
        _phi: degToRad(10)
      })(sphere);
      addConeParentWithParams({
        _volume: 2,
        _spread: 0.3,
        _theta: degToRad(-90),
        _phi: degToRad(-70)
      })(sphere);
      addConeParentWithParams({
        _volume: 3,
        _spread: 1.2,
        _theta: degToRad(40),
        _phi: degToRad(0)
      })(sphere);
      addConeParentWithParams({
        _volume: 2,
        _spread: 0.3,
        _theta: degToRad(-120),
        _phi: degToRad(-90)
      })(sphere);
      return sphere;
    })();
    isIpad = navigator.userAgent.match(/iPad/i) !== null;
    if (isIpad === true) {
      highlightObject(big);
    }
    (function() {
      var _trajectory, p, sphere;
      p = new THREE.Vector3(4, 4, -2);
      sphere = addObjectAtPoint(p);
      [0, 90, 180, 270].map(function(t) {
        return [0, 90, 180, 270].map(function(p) {
          return addConeParentWithParams({
            _volume: 1.5,
            _spread: 0.5,
            _theta: degToRad(t),
            _phi: degToRad(p)
          })(sphere);
        });
      });
      _trajectory = (function() {
        var geometry, mat, obj, sampleClosedSpline;
        sampleClosedSpline = new THREE.ClosedSplineCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(2, 1, -2), new THREE.Vector3(2, -1, -2), new THREE.Vector3(3, 2, 3), new THREE.Vector3(3, -1, 6)]);
        geometry = new THREE.TubeGeometry(sampleClosedSpline, 100, 0.05, 8, true);
        mat = new THREE.MeshPhongMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.5
        });
        obj = new THREE.Mesh(geometry, mat);
        obj.castShadow = true;
        return obj;
      })();
      sphere.add(_trajectory);
      return sphere.position.copy(new THREE.Vector3(2, 4, -10));
    })();
    _spoof = (function() {
      var _trajectory, p, sphere;
      p = new THREE.Vector3(-7, -0.5, 3);
      sphere = addObjectAtPoint(p, 0.7);
      addConeParentWithParams({
        _volume: 2,
        _spread: 0.5,
        _theta: 0,
        _phi: Math.PI / 2
      })(sphere);
      addConeParentWithParams({
        _volume: 1.2,
        _spread: 0.7,
        _theta: Math.PI * 0.3,
        _phi: -Math.PI * 0.1
      })(sphere);
      _trajectory = (function() {
        var geometry, mat, obj, sampleClosedSpline;
        sampleClosedSpline = new THREE.ClosedSplineCurve3([new THREE.Vector3(0, 0, 0), new THREE.Vector3(4, -1, -4), new THREE.Vector3(9, 1, -4), new THREE.Vector3(4, 2, 4), new THREE.Vector3(-4, -1, 4)]);
        geometry = new THREE.TubeGeometry(sampleClosedSpline, 100, 0.05, 8, true);
        mat = new THREE.MeshPhongMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.5
        });
        obj = new THREE.Mesh(geometry, mat);
        obj.castShadow = true;
        if (!isIpad) {
          sampleClosedSpline.points.forEach(function(p) {
            var controlPoint, material;
            geometry = new THREE.SphereGeometry(0.2, 30, 30);
            material = new THREE.MeshPhongMaterial({
              color: PARENT_SPHERE_COLOR,
              transparent: true,
              opacity: 0.5
            });
            controlPoint = new THREE.Mesh(geometry, material);
            controlPoint.castShadow = true;
            controlPoint.receiveShadow = true;
            controlPoint.name = 'parentSphere';
            controlPoint._volume = 0;
            controlPoint.renderOrder = 10;
            controlPoint.position.copy(p);
            return obj.add(controlPoint);
          });
        }
        return sphere.add(obj);
      })();
      return sphere;
    })();
    coneParent = _spoof.children[1];
    isIpad = navigator.userAgent.match(/iPad/i) !== null;
    if (!isIpad) {
      highlightObject(coneParent.getObjectByName('cone'));
    }
    if (isIpad === true) {
      _spoof = big;
    }
    wid = dom.sceneControls.node().clientWidth * 0.6;
    if (!isIpad) {
      port = dom.sceneControls.append('div').classed('card', true).style('height', wid + "px");
      _canv = port.append("canvas");
      _rend = new THREE.WebGLRenderer({
        canvas: _canv.node(),
        antialias: true
      });
      _rend.setClearColor('white');
      _scene = new THREE.Scene();
      _rend.setSize(port.node().clientWidth, port.node().clientHeight);
      cloned = _spoof.clone();
      spotLight = new THREE.SpotLight(0xffffff, 0.95);
      spotLight.position.setY(100);
      spotLight.castShadow = true;
      spotLight.shadowMapWidth = 4000;
      spotLight.shadowMapHeight = 4000;
      spotLight.shadowDarkness = 0.001;
      hemisphere = new THREE.HemisphereLight(0, 0xffffff, 0.8);
      _scene.add(hemisphere);
      _scene.add(spotLight);
      c = new THREE.OrthographicCamera();
      c.zoom = INITIAL_ZOOM * 1.5;
      c._lookAt = new THREE.Vector3();
      c.position._polar = {
        radius: CAMERA_RADIUS,
        theta: degToRad(INITIAL_THETA),
        phi: degToRad(INITIAL_PHI)
      };
      c.position._relative = polarToVector(c.position._polar);
      c.position.addVectors(c.position._relative, c._lookAt);
      c.lookAt(cloned.position);
      c.up.copy(new THREE.Vector3(0, 1, 0));
      s = {
        width: port.node().clientWidth,
        height: port.node().clientHeight
      };
      ref = [-1, 1].map(function(d) {
        return d * s.width / 2;
      }), c.left = ref[0], c.right = ref[1];
      ref1 = [-1, 1].map(function(d) {
        return d * s.height / 2;
      }), c.bottom = ref1[0], c.top = ref1[1];
      c.updateProjectionMatrix();
      camera = c;
      _scene.add(cloned);
      i = 0;
      d3.timer(function() {
        var sc;
        i++;
        sc = new THREE.Scene();
        sc.add(spotLight);
        cloned = _spoof.clone();
        cloned.remove(cloned.children[0]);
        cloned.remove(cloned.children[2]);
        cloned.rotateY(degToRad(45));
        sc.add(cloned);
        _rend.render(sc, camera);
        if (i === 40) {
          return true;
        }
        return false;
      });
    }
    dom.sceneControls.append('div').classed('card', true).call(function(card) {
      card.append('div').classed('card-block', true).attr('id', 'cone-card').style({
        'border-top': 'none'
      }).call(function(block) {
        block.append('h6').classed('card-title', true).text('Cone 1.2');
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('File');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).append('span').text('cone.wav');
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Volume');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).append('span').text(coneParent._volume + " dB");
        });
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Spread');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).append('span').append('span').text(coneParent._spread);
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Pitch');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).append('span').append('span').text((degToRad.invert(coneParent._phi)) + "°");
        });
        return block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-6', true).append('span').classed('value', true).text('Delete');
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Yaw');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).append('span').text((degToRad.invert(coneParent._theta)) + "°");
        });
      });
      card.append('div').classed('card-block', true).attr('id', 'object-card').call(function(block) {
        block.append('h6').classed('card-title', true).text(function() {
          if (isIpad) {
            return 'Object 2';
          } else {
            return 'Object 1';
          }
        });
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('File');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('None');
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Volume');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text("95%");
        });
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('x');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text(_spoof.position.x + " m");
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Cones');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text(function() {
            if (isIpad) {
              return 4;
            } else {
              return 2;
            }
          });
        });
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('y');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text(_spoof.position.y + " m");
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Pitch');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text((degToRad.invert(_spoof.rotation.x)) + "°");
        });
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('z');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text(_spoof.position.z + " m");
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Yaw');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text((degToRad.invert(_spoof.rotation.z)) + "°");
        });
        return block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('Delete');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('Duplicate');
          return row.append('div').classed('col-xs-6', true).append('span').classed('value', true).attr('id', 'add-trajectory').style({
            'border-bottom': 'none',
            opacity: 0.4
          }).text('Add Trajectory');
        });
      });
      return card.append('div').classed('card-block', true).attr('id', 'trajectory-card').call(function(block) {
        block.append('h6').classed('card-title', true).text('Trajectory');
        block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Speed');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('0.5 m/s');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('Pause');
        });
        return block.append('div').classed('row parameter', true).call(function(row) {
          row.append('div').classed('col-xs-3', true).append('span').classed('key', true).text('Resolution');
          row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('4');
          return row.append('div').classed('col-xs-3', true).append('span').classed('value', true).text('Delete');
        });
      });
    });
    if (isIpad === true) {
      d3.select('#trajectory-card').remove();
      d3.select('#cone-card').remove();
      d3.select('#object-card').style('border', 'none');
      d3.select('#add-trajectory').style({
        'border-bottom': '1px dotted #333',
        opacity: 1
      });
    }
    _room = (function() {
      var geom, l, mat, obj, w;
      w = ROOM_SIZE.width;
      l = ROOM_SIZE.length;
      geom = new THREE.PlaneGeometry(w, l);
      mat = new THREE.LineBasicMaterial({
        color: "#000",
        depthWrite: false,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.05
      });
      obj = new THREE.Mesh(geom, mat);
      obj.rotateX(Math.PI / 2);
      obj.position.setY(-ROOM_SIZE.height / 2);
      obj.receiveShadow = true;
      obj.updateMatrixWorld();
      return obj;
    })();
    model.scene.add(_room);
    _zone = (function() {
      var curve, geometry, material, obj, shape;
      curve = new THREE.ClosedSplineCurve3([new THREE.Vector2(5, -2), new THREE.Vector2(8, 6), new THREE.Vector2(1, 3), new THREE.Vector2(-2, 7), new THREE.Vector2(-5, 0), new THREE.Vector2(-2, -2)]);
      shape = new THREE.Shape();
      shape.fromPoints(curve.getPoints(50));
      geometry = new THREE.ShapeGeometry(shape);
      material = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      obj = new THREE.Mesh(geometry, material);
      obj.rotateX(Math.PI / 2);
      obj.position.setY(-ROOM_SIZE.height / 2);
      return obj;
    })();
    model.scene.add(_zone);
    (function() {
      var curve, geometry, material, obj, shape;
      curve = new THREE.ClosedSplineCurve3([new THREE.Vector2(0, 0), new THREE.Vector2(0, 2), new THREE.Vector2(2, 6), new THREE.Vector2(5, 0)]);
      shape = new THREE.Shape();
      shape.fromPoints(curve.getPoints(50));
      geometry = new THREE.ShapeGeometry(shape);
      material = new THREE.MeshPhongMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide,
        depthWrite: false
      });
      obj = new THREE.Mesh(geometry, material);
      obj.rotateX(Math.PI / 2);
      obj.position.setY(-ROOM_SIZE.height / 2);
      obj.position.setX(-4);
      obj.position.setZ(-4);
      obj.rotateZ(degToRad(45));
      if (!isIpad) {
        return model.scene.add(obj);
      }
    })();
    (function() {
      var _neck, _nose, geometry, material, neck, nose, sphere;
      geometry = new THREE.SphereGeometry(0.5, 30, 30);
      material = new THREE.MeshPhongMaterial({
        color: new THREE.Color("#00ffcc"),
        transparent: true,
        opacity: 0.5
      });
      sphere = new THREE.Mesh(geometry, material);
      sphere.castShadow = true;
      sphere.receiveShadow = true;
      sphere.name = 'parentSphere';
      sphere._volume = 0;
      sphere.renderOrder = 10;
      _neck = new THREE.CylinderGeometry(0.2, 0.2, 0.5);
      neck = new THREE.Mesh(_neck, material);
      neck.position.y = -0.7;
      neck.castShadow = true;
      sphere.add(neck);
      _nose = new THREE.TetrahedronGeometry(0.3);
      nose = new THREE.Mesh(_nose, material);
      nose.castShadow = true;
      nose.rotateY(degToRad(0));
      nose.rotateZ(degToRad(-45));
      nose.rotateX(degToRad(-45));
      nose.rotateX(degToRad(90));
      nose.position.setX(-0.5);
      sphere.add(nose);
      isIpad = navigator.userAgent.match(/iPad/i) !== null;
      if (!isIpad) {
        sphere.position.copy(new THREE.Vector3(5, 2, 1));
        sphere.rotateY(degToRad(90));
      }
      if (isIpad === true) {
        sphere.position.copy(new THREE.Vector3(0, 2, -4));
        sphere.rotateY(degToRad(-50));
      }
      sphere.scale = 0.5;
      return model.scene.add(sphere);
    })();
    emitter.emit('modelUpdate', function(m) {
      return m;
    });
    isIpad = navigator.userAgent.match(/iPad/i) !== null;
    if (!isIpad) {
      canvas = dom.miniCube.node();
      ss = 100;
      __camera = new THREE.PerspectiveCamera(75, ss / ss, 0.1, 1000);
      __camera.position.z = 2;
      __renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true,
        alpha: true
      });
      __renderer.setSize(ss, ss);
      __geometry = new THREE.BoxGeometry(1, 1, 1);
      __material = new THREE.MeshBasicMaterial({
        color: 0,
        wireframe: true
      });
      __cube = new THREE.Mesh(__geometry, __material);
      __cube.updateMatrix();
      lines = new THREE.EdgesHelper(__cube, 0);
      lines.matrixAutoUpdate = true;
      little = new THREE.Object3D();
      little.add(lines);
      x = 0.3;
      grid = new THREE.GridHelper(x * 2 + 0.31, x);
      grid.rotateZ(degToRad(90));
      little.add(grid);
      offsetZ = 0.1;
      __scene = new THREE.Scene();
      __scene.add(little);
      foo = function() {
        requestAnimationFrame(foo);
        little.rotation.y = -model.camera.position._polar.theta;
        little.rotation.z = model.camera.position._polar.phi;
        little.rotation.x = 0.5;
        return __renderer.render(__scene, __camera);
      };
      foo();
    }
    dom.main.append('div').attr('id', 'mode-text').style({
      position: 'absolute',
      'font-size': '0.6rem',
      right: '128px',
      bottom: '65px'
    }).append('span').style({
      'border-bottom': '1px dotted #333',
      'font-size': '0.8rem'
    }).text('Altitude Mode');
    if (isIpad === true) {
      dom.main.select('.cameraControls').remove();
      d3.select('#mode-text').style({
        right: '10px',
        bottom: '10px'
      }).select('span').text('Lateral Mode');
      dom.main.select('#sceneControls').style('width', '35vw');
      d3.selectAll('.parameter span').style('font-size', '0.8rem');
      return d3.selectAll('.row.parameter').style('line-height', '2');
    }
  });

  console.log('test');

  emitter.emit('start');

  emitter.emit('mockup');

}).call(this);
